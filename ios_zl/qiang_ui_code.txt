NSStringFromClass([AppDelegate class])//获取类名当做字符串,
NSStringFromNSRange(NSMakeRange{1,3})//获取范围当做字符串,输出结果是如{1,3}
CGPointMake,     CGRectMake(Rect方形)

window调用mianView,mianView再调用其它子窗口
UIwindow——>mainView—->subView
[self.window makeKeyAndVisible];//将该 UIWindow 对象设为主窗口，并显示出来
[button removeFromSuperview];移除按钮(注意有的时候,如果移除不了控件,可以直接移除控件所在的视图View)

//为文本框添加此标签：
        _textField.leftView=label;
      (  _textField.rightView=imageView;(设置右视图是图片))
        //设置标签的显示模式(一直显示)：
        _textField.leftViewMode=UITextFieldViewModeAlways

只要是控制事件的基本上都会先(同时)把下面的代码执行一便,然后再进入死循环(),换句话说,也就是这个事件发生之前要把该函数里的代码都执行一遍
两个两个以上的事件,则按事件的前后顺序去执行,
[_imageView startAnimating];
[NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(setProgress:) userInfo:nil repeats:NO];
[_slider addTarget:self action:@selector(sliderMove:) forControlEvents:UIControlEventValueChanged];
等等
其实控制事件都是对模拟器操作的监控,并且操作后通过监控的方式(UIControlEventValue等等)可以改变代码中的一些属性值,比如UISlider的value,UIButton的ON,UISwitch的Value等等

上下拉刷新要注意顺序
[_tableView reloadData];
[_headerView egoRefreshScrollViewDataSourceDidFinishedLoading:_tableView];;注意它两个的先后顺序

用扩展类的方法,去扩展,比如对UIImageView进行扩展类方法,那么返回的仅仅是UIImageVIew的frame大小,在它之外的都显示不了,除非是加在它上面的子控件

UI里的函数都是通过对模拟器的空间操作触发的
UIViewControl继承自UIResponder,UIResponder继承自NSObject
UIControl继承于UIView

不同视图控制器之间有正向传值和反向传值,其实正向传值就是自己定义一个类的实例变量,用法和类中带有的系统实例变量属性是一样子的

反向传值:找代理的对象,一般接收到某个信息,但是该信息自己却处理不了,那么只能找代理去帮自己完成.
可以通过代理方法去传参数(原理是:函数的调用带参—自己根本处理不了的操作),和利用函数的返回值(只需要一个参数就可以自己去处理操作))

反向传值有三种方法:
1)单例UIApplication([UIApplication sharedApplication]),(NSUserDefaults这个只是程序第一次加载存入的少量数据——[NSUserDefaults standardUserDefaults])
2)代理
3)通知中心([NSNotificationCenter defaultCenter])
4)block函数

NSResponder的方法
(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;

UIControlContentHorizontalAlignment,UIControlContentVerticalAlignment枚举值,textField的text具有contentHorizontalAlignment这样的属性
	1  // Set up the button aligment properties  
2 button.contentVerticalAlignment = UIControlContentVerticalAlignmentCenter;  
3  button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentCenter;

系统自带的init方法里面,尽量不要去去调用自定义函数方法.避免出错

UITextView,UITableView继承于UIScrollView
把它们加入导航控制器的时候都需要设置该属性self.automaticallyAdjustsScrollViewInsets=NO;

viewController.hidesBottomBarWhenPushed
cell.accessoryView
类的有些实例变量属性可能是readOnly,但是我们可以通过.点语法取设置该属性下的子属性(tabelViewCell.textLabel.font,tabelViewCell.tetLabel.text等等——-button.titleLabel.font,button.titleLabel.adjustsFontSizeToWidth)

toolBar默认高度49,navigationBar默认高度44,tableViewCell默认高度44
由于toolBar,navigationBar都是继承自UIView的,而且它们都是加在ViewController的视图上,所以它们不会影响viewcontroller.view的frame
cell的bounds.size的默认height和weight
CustomTableViewCellDemo[26106:1569991] 44.000000,320.000000
自定义Cell的时候要注意

开启用户互动_label.userInteractionEnabled=YES;

添加动画,只有CATransition *transition[CATransition animation];,CABasicAnimation *basicAnimation = [CABasicAnimation animationWithKeyPath:@"position"];才会用到[self.view.layer addAnimation:transition forKey:nil];该方法

UITableView删除cell时候.添加动画
[_tableView beginUpdates];
[_tableView deleteRowsAtIndexPaths:@[indexPath]  withRowAnimation:UITableViewRowAnimationMiddle];
[_tableView endUpdates];

通知中心在一个视图控制中心里只能NSNotificationCenter *news=[NSNotificationCenter defaultCenter];
[news addObserver:self selector:@selector(dealWithData:) name:@"news" object:nil];添加观察者一次,
同一个消息的名字name:@“news”可以对应对个消息(是因为你多次调用了上面的方法,即就会添加了多个观察者),而且消息的方法selector(dealWithData:)在观察者接收到一个新的news,就会去执行,方法的调用是系统自动调用的.

ARC   assign,   copy  , strong, weak,
系统自动管理内存,assign,用于基本的类型,int,NSInteger等等
copy,跟MRC的相似,都是对字符串的拷贝过来,是深拷贝
strong,对应MRC的retain,只要引用对象就可以用,除了代理,注意NSString类型的strong时候与copy的区别,strong是把NSString对象的地址传过来(+1),可以通过地址对NSString对象进行操作,而copy不行,copy的操作仅仅是拷贝(跟电脑的拷贝功能差不多)
weak常用于代理对象
 
MRC 手动管理内存 assign, copy,retain,delease

//_searchData=[NSMutableArray array];,如果在这里(进入搜索以后调用代理方法)初始化,那么搜索结束以后,调用didDismissSearchController:该语句之前,就会自动释放它的内存

隐藏UITabbar
self.hidesBottomBarWhenPushed=YES;
[self.navigationController pushViewController:subVC animated:YES];
self.hidesBottomBarWhenPushed=NO;

sd_setImageWithURL:URL placeholderImage:占位图片options:参数设置加载图片失败是否尝试重新加载等等

返回字符串,串中的每个单词的首字母大写,其余字母小写
- (NSString *)capitalizedString;
 
返回转换为小写的字符串
- (NSString *)lowercaseString;
 
返回转换为大写的字符串
(NSString *)uppercaseString;

- (BOOL)hasPrefix:(NSString *)aString;
- (BOOL)hasSuffix:(NSString *)aString;

比较两个字符串 (忽略大小写)
(NSComparisonResult)caseInsensitiveCompare:(NSString *)string;

归档自定义对象的时候,要对对象的那个属性归档方式进行设置
[NSKeyedArchiver archiveRootObject:<#(id)#> toFile:<#(NSString *)#>];
这个对象在进行归档时候要设置方式为:[aCoder encodeObject:string forKey:@“citySection”];[aCoder encodeObject:string2 forKey:@“key”];

当归档的对象是NSString,NSArray等等时候,则不用调用归档方法- (void)encodeWithCoder:(NSCoder *)aCoder去设置

//——添加动画———————-但是动画是整个视图的移动——
_scrollView.transform = CGAffineTransformMakeTranslation(0,-kBottomMenuItemH);
[UIView animateWithDuration:1 animations:^{
_scrollView.transform = CGAffineTransformIdentify;
//CGAffineTransformIdentify,单位矩阵,清空以前所有的矩阵(所有的形变属性)
}];
//注意动画结束以后,要记得还原CGAffineTransformIdentify;,否则会frame出现问题

block函数用copy属性
block内存泄露的解决,反复回调
// 设置block回调
    __unsafe_unretained TGDealTopMenu *menu = self;
    _showingMenu.hideBlock = ^{
        // 1.取消选中当前的item
        menu->_selectedItem.selected = NO;
        menu->_selectedItem = nil;
        
        // 2.清空正在显示的菜单
        menu->_showingMenu = nil;
    };

类的对象->属性,表示访问类对象的内部成员变量

[self.subviews makeObjectsPerformSelector:@selector(removeFromSuperView)];
数组里面的所有元素都执行removeFromSuperView方法,移除所有的子视图
- (void)setTitles:(NSArray *)titles
{
    _titles = titles;
    
    int count = titles.count;
    // 设置按钮的文字
    for (int i = 0; i<count; i++) {
        // 1.取出i位置对应的按钮
        UIButton *btn = nil;
        if (i >= self.subviews.count) { // 按钮个数不够
            btn = [UIButton buttonWithType:UIButtonTypeCustom];
            [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
            [self addSubview:btn];
        } else {
            btn = self.subviews[i];
        }
        
        // 2.设置按钮文字
        btn.hidden = NO;
        [btn setTitle:titles[i] forState:UIControlStateNormal];
    }
    
    // 隐藏后面多余的按钮
    for (int i = count; i<self.subviews.count; i++) {
        UIButton *btn = self.subviews[i];
        btn.hidden = YES;
    }
}
隐藏多余的按钮,创建少的按钮

- (void)layoutSubviews;控件,当自己的宽高(frame和size和bounds等)改变时,系统调用,还有当有子视图加入的时候也调用[self addSubview:_imageView];

判断某个视图是不是第一次加进父视图去,可以判断if(view.superView==nil){}

[self.navigationController   addChildViewController:navigation];当两个控制器为父子关系的时候,其视图也互为父子关系

//给文字添加删除线的方法
NSString *lastString = [NSString stringWithFormat:@"$:%@",model.lastPrice];
NSAttributedString *subString = [[NSAttributedString alloc]initWithString:lastString attributes:@{NSStrikethroughStyleAttributeName:@1}];
self.lastLabel.attributedText = subString;

- (void)awakeFromNib
{
    [self buttonClick:_infoBtn];
}//xib调用的方法
(id)initWithCoder:(NSCoder *)aDecoder

NSString *title = [btn titleForState:UIControlStateSelected];
NSInteger index = title.integerValue;

//要向地图打开的时候,就显示当前位置,必须调用- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(MyAnnotation*)annotation方法,如果该方法返回空,则用系统自带的空间显示,如果是大头针,则以大头针的样式显示

有些变量只需要初始化一次（如从文件中读取配置参数，读取设备型号等等），可以使用dispatch_once来进行读取优化，保证只调用API一次，以后就只要直接访问变量即可
dispatch_once不仅意味着代码仅会被运行一次，而且还是线程安全的，这就意味着你不需要使用诸如@synchronized之类的来防止使用多个线程或者队列时不同步的问题。

//alloc底层调用allocWithZone可以避免乱调用alloc方法
//重写allocWithZone该方法，控制内存的分配，永远只分配一次存储空间
#define singleton_implementation(className) \
static className *_instance; \
+ (id)allocWithZone:(NSZone *)zone \
{ \
    static dispatch_once_t onceToken; \// 创建队列
    dispatch_once(&onceToken, ^{ \         //
        _instance = [super allocWithZone:zone]; \ 
    }); \
    return _instance; \
} \
+ (className *)shared##className \
{ \
    static dispatch_once_t onceToken; \
    dispatch_once(&onceToken, ^{ \
        _instance = [[self alloc] init]; \
    }); \
    return _instance; \
}
在对象初始化分配内存的时候都会调用这个方法，重写该方法时，即便用户没用通过shared方法获取实例，自己初始化依然可以保证得到的是同一个实例。
在gcd后，多线程下保证一个代码只被执行一次提供了一个便捷的方式就是dispatch_once。
采用 [[self class] alloc] 时，如果类派生了子类，产生的将是类型相同的子类对象，而不是基类对象，

SEL selector = NSSelectorFromString(name);从字符串中获得方法名字
//iOS7之后
CGRect textBounds = [model.body boundingRectWithSize:CGSizeMake(280, CGFLOAT_MAX) options:NSStringDrawingUsesLineFragmentOrigin attributes:dict context:nil];
label.lineBreakMode = NSLineBreakByCharWrapping;
//iOS7之前
CGSize size=[_text.text sizeWithFont:_text.font constrainedToSize:CGSizeMake(300, 10000) lineBreakMode:NSLineBreakByCharWrapping];
可以用于求控件文本字符串的宽度和高度
可以通过_text.contentSize.height(width)求,但是对于UITextView用_text.contentSize只能求高度,constrainedToSize:CGSizeMake(300, 10000)限制最大的宽度和高度
l另外该方法,可以求取所有字符串的长度,只要明确字符串的字体,就可以

在设置控件文本的时候,要注意是否是readOnly等等,否则即使输入代码的时候有提示,但也不能实现

注意:_window不管切换到那个视图,永远是在最低层,因此在_window上加入的控件或者视图也永远在底层,因此往_window里加入的时候要注意加入的先后顺序,否则出现一个遮盖问题

一般只要继承自uiView和UIControl的都有frame和backgroundColor属性,目前除了UIVIewController,UINavigationController(继承自UIViewController)以外
继承与UIControl都有borderStyle

UIFond 类用+ (NSArray *)familyNames;求字体名字
 + (UIFont *)systemFontOfSize:(CGFloat)fontSize;
 + (UIFont *)boldSystemFontOfSize:(CGFloat)fontSize;
 +(UIFont *)italicSystemFontOfSize:(CGFloat)fontSize;
 + (UIFont *)fontWithName:(NSString *)fontName size:(CGFloat)fontSize
 - (UIFont *)fontWithSize:(CGFloat)fontSize;
_text.font=[_text.font fontWithSize:15];而不能直接[_text.font fontWithSize:15],

——————————————制作动画移动控件里内容——————
[UIView animateWithDuration:5 animations:^
     {CGPoint offset=_myscrollview.contentOffset;
         offset.y+=150;
         _myscrollview.contentOffset=offset;
    }];

//---------------------------注册cell-----------------
    UINib *nib=[UINib nibWithNibName:@"DataCell" bundle:nil];
    [self.tableView registerNib:nib forCellReuseIdentifier:@"cellId"];

if([path rangeOfString:@"http://"].location != NSNotFound ||[path rangeOfString:@"https://"].location != NSNotFound)
{
    //创建在线的url
    url = [NSURL URLWithString:path];
}
else
{
    //创建本地的url
    url = [NSURL fileURLWithPath:path];
}

//去掉搜索框前面的遮罩
    _searchCtrl.dimsBackgroundDuringPresentation = NO;

UIImage *image = info [UIImagePickerControllerOriginalImage];
   //将图片存储到手机相册里面(当再次进入相册的时候UIImagePickerController可以显示出刚才存进相册去的照片)
   UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);

- (UIImage *)backgroundImageForState:(UIControlState)state;
UIButton的方法,用于获取图片

在cell的init方法中初始化并一些控件加入视图,可以避免控件重复叠加的问题

类方法里不可以含有实例变量的参数,因此,要想传入参数,必须要用带有参数的方法,而不能用类的属性作为参数,另外类方法的优点就是,不需要初始化类的对象,这样一方便可以节省控件,另一方面也可以以避免初始化类的对象,而不能再利用原来实例变量的属性参数

xib中使用自适应高度
CGRect textBounds = [model.body boundingRectWithSize:CGSizeMake(280, CGFLOAT_MAX) options:NSStringDrawingUsesLineFragmentOrigin attributes:dict context:nil];
label.lineBreakMode = NSLineBreakByCharWrapping;
记住要把xib的自动管里高度关掉

[self.navigationController pushViewController:ctrl animated:YES];
push的时候才会调用viewDidload方法,所以给实例变量辅助需要在push之前赋值,但是仅仅 是第一次推入的时候调用,以后每一次推入仅仅调用willAppear等等

消息控制中心必须在dealloc之前remove掉

消息控制中心,观察者要放在发送消息之前,所以在添加观察者的时候不需要设置观察到的数据类型,系统会把它放在消息的属性里,可以直接点语法出来,而发送消息则需要设置发送消息的类型,
[NSNotificationCenter defaultCenter]postNotificationName:object:参数放在这里;
[NSNotificationCenter defaultCenter]postNotificationName:object:userInfo:参数放在这里

工程里面的Main Interface:Main 的作用是系统将ViewController与AppDelegate类关联起来(通过Main.stroyboard),直接把ViewController类的对象关联成rootViewController,不用再在AppDelegate.m里去用self.window.rootViewController;语句,系统自己会默认生成

所有继承于UIView的共性:长按(手势)事addGestureRecognizer:件,hidden,(layer)cornerRadius.maskTobounds,layer.borderColor,layer.borderColor,userInteractionEnabled,pagingEnabled(只有部分公有,UIScrollView—UITabelView等,等),clipsToBounds,alpha,enabled(是否能够被点击),editing(编辑状态),allowsSelection(是否能被选中,UITableView),tintColor,highlighted(UILabel),adjustsFontSizeToFitWidth

所有继承于UIControl的共性:
addTarget:等等点击事件,可以通过底层绘画(layer)取修改边框和边框颜色

//利用三原色随机,arc4random()
view.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0f green:arc4random()%255/255.0f blue:arc4random()%255/255.0f alpha:1.0f];

单例
存在的周期:是从第一期创建到整个程序结束,中间,不管多少次初始化,只有第一次初始化真正初始化了
单例的初始化
+(instanceType)defaultManager
{
    @synchronized(self)
    {//考虑到线程安全
        //加锁
        if(!manager)
        {
            manager = [[self alloc] init];
        }
    }
    return manager;//注意这里返回的不是self
}

[pageControl addTarget:self action:@selector(pageTurn:) forControlEvents:UIControlEventTouchUpInside];这个事件传递的参数就是pageControl本身

一个视图控制器,只要初始化init完成,那么当视图控制器在模拟器界面上显示的时候,他的视图就会自动的被调出来,视图控制器的属性只需要在视图控制器的类方法实现的函数里面去设置就可以了,在任何时候去初始化视图控制器,它的视图属性都是一样的

//UIBarButtonItem * item = [[UIBarButtonItem alloc] initWithCustomView:btn];自定义UINavigationItem上面的按钮
btn的frame上的x,y对Item没有影响,影响的仅仅是frame的width,height

常用的OC知识:- (BOOL)containsString:(NSString *)aString
- (BOOL)containsObject:(id)anObject;

firstCtrl.tabBarItem.image=[[UIImage imageNamed:@"tab_0.png"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];//设置图片,Rendering表现,Original最初的
[firstCtrl.tabBarItem setTitleTextAttributes:@{NSForegroundColorAttributeName:[UIColor purpleColor]} forState:UIControlStateNormal];//设置文字颜色,AttributeName属性名字

一些继承UIView的高级控件都有自己的视图控制器.UIScrollView,UITableView,UIWebView

//- (instancetype)initWithCustomView:(UIView *)customView;
//UIBarButtonItem可以通过该方法去自定义一个视图,间接的去自定义UIToolBar的上面视图

UINavigationItem.titleView来设置UINavigationItem的自定义视图

一个UINavigationController自动创建一个UINavigaitonBar和一个UIToolBar
一个UIViewControl(当ViewController加入UInavigationController以后)系统自动创建一个UINavigationItem和一个UIToolItem.
一个UIToolItem对应多个UIButtonBarItem,viewController.toolItems=array的方式

UINavigationBar,UITabBar,UIToolbar 都继承于UIView,所以它们有hidden的属性,但是控制(初始化)它们的是UINavigationController
它们各自都不具有UI***Item属性,UI***Item是继承自NSObject,受UIViewController控制

firstCtrl.tabBarItem.imaged点语法取设置属性
firstCtrl.tabBarItem.title
也可以———————
UITabBarItem *item2=[[UITabBarItem alloc]init];
    item2.title=@"2";
    item2.image=[UIImage imageNamed:@"tab_0"];
    secondCtrl.tabBarItem=item2

UINavigationController : UIViewController
UITabBarController : UIViewController
 UIViewController : UIResponder
 {
    @package
    UIView           *_view;
    UITabBarItem     *_tabBarItem;
    UINavigationItem *_navigationItem;
    NSArray          *_toolbarItems;
}
子类继承父类的时候,要注意:只能继承属性和方法,响应事件(Button等等),应该写在子类
但是可以自己在父类写方法,不具体指明target和action,而在子类指明

 //背景图片
    [self.navigationController.navigationBar setBackgroundImage:[UIImage imageNamed:@"bar_bj.png"] forBarMetrics:UIBarMetricsDefault];
//navigationItem title的颜色
    NSDictionary *navTitleArr = [NSDictionary dictionaryWithObjectsAndKeys:[UIColor whiteColor],NSForegroundColorAttributeName,nil];
    self.navigationController.navigationBar.titleTextAttributes = navTitleArr;

self.navigationController.navigationBar setTitleTextAttributes:<#(NSDictionary *)#>

[self.navigationController.navigationBar setBackgroundImage:image2 forBarMetrics:UIBarMetricsLandscapePhone]

//UIBarMetricsDefault指的是手机竖直方向的NavigationBar,另外一个常用的UIBarMetricsLandscapePhone指的是手机横向的NavigationBar。

//设置UIImage的渲染模式：UIImage.renderingMode
tabBarItem.selectedImage=[[UIImage imageNamed:imageArray[i]]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];

tabBarItem setTitleTextAttributes:@{NSForegroundColorAttributeName:[UIColor redColor]} forState:UIControlStateNormal

(UIImage *)stretchableImageWithLeftCapWidth:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight
这个函数是UIImage的一个实例函数，它的功能是创建一个内容可拉伸，而边角不拉伸的图片，需要两个参数，第一个是左边不拉伸区域的宽度，第二个参数是上面不拉伸的高度。
根据设置的宽度和高度，将接下来的一个像素进行左右扩展和上下拉伸。
参数的意义是，如果参数指定10，5。那么，图片左边10个像素，上边5个像素。不会被拉伸，x坐标为11和一个像素会被横向复制，y坐标为6的一个像素会被纵向复制。注意：只是对一个像素进行复制到一定宽度。而图像后面的剩余像素也不会被拉伸
注意：可拉伸的范围都是距离leftCapWidth后的1竖排像素，和距离topCapHeight后的1横排像素。,但是拉伸虽然没设置大小,但是它默认的是拉倒图片添加视图的frame边界

-(UIView*)hitText(CGPoint)point withEvent(UIEvent)event;返回的是self(如果事件不是发生在该视图上,则返回空),用于iOS操作系统找出具体的事件发生的视图.(通过遍历的方法)

//枚举值用位或的方法来取多个值
    vSwipeGes.direction=UISwipeGestureRecognizerDirectionUp|UISwipeGestureRecognizerDirectionDown;
    //建立手势与视图之间的关联,但是仅仅只是关联,没有父子视图的关系(这个与View的区别)
    [self.view addGestureRecognizer:vSwipeGes];

toolBar,tabBar系统默认的高度分别为:44,49

UITapGestureRecognizer *tapGest=[[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapGest:)];
    [label addGestureRecognizer:tapGest];
    [image addGestureRecognizer:tapGest];这样写是错误的,一个手势只能对应一个视图

单例方法里无法设置属性,印版情况下通过单例方法调用init方法,在通过init方法去设置属性

类方法不可以用self取调用类对象的实例变量属性,但可以去调用本类的其它类方法

写类方法的好处是:不需要创建类的实例对象,就可以去调用,这样节省空间内存
frame                                               坐标
text                                               显示文字
textColor                                       文字颜色
textAlignment                               文字对齐方式
font                                                   字体                                       
backgroundColor                           背景颜色

shadowColor                                    文字阴影颜色
shadowOffset                                   文字阴影偏移量
highlighted                                        设置高度
highlightedTextColor                          设置高亮颜色
adjustsFontSizeToFitWidth                根据Label宽度设置字体大小
baselineAdjustment                           设置基线位置
numberOfLines                     设置最大行数(当为0的时候,显示可以从顶部开始)
lineBreakMode                                   设置内容超出宽度时的模式

@property(nonatomic,retain)     UIColor *highlightedTextColor; // default is nil
@property(nonatomic,getter=isHighlighted) BOOL     highlighted; 
两个连在一起使用

CGSize
—>CGSizeMake(CGFloat width, CGFloat height)

CGPoint
—>CGPointMake(CGFloat x, CGFloat y)

CGRect
—>CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height)

label.numberOfLines=0;//设置最大行数(如果为0,则代表不限制最多显示行数)

UIlabel添加背景图片
UIColor *color = [UIColor colorWithPatternImage:[UIImage imageNamed:@"itemkaung2.png"]];
[myLabel setBackgroundColor:color];
image                                                  图片
animationImages                              动画数组
animationDuration                动画周期(即设置一组动画的播放一次需要的时间)
animationRepeatCount                    动画循环次数//如果不设置(或者为0时),则无限播放
contentMode                                     内容模式
CGSize             size;

-(void)startAnimating                         开始动画
-(void )stopAnimating                         结束动画
-(BOOL)isAnimating                          是否在动画中

//image没有frame这个属性,而要显示在屏幕上必须要有frame,因此必须借助一个载体,在这里可以用imageView充当image的载体

//要想原图显示,可以设置CGRectMake{ , ,image.width,height};

注意:动画播放
,[NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(setProgress:) userInfo:nil repeats:YES];
外面不能套死循环,否则,程序不执行动画播放语句,它本身就是一个死循环,而且在附近程序代码同时执行,不管是在该语句之前还是之后,都是与该语句同时执行,该语句可以看成一个死循环,当repeats:YES不跳出死循环,当repeats:NO跳出死循环;另外循环一次,就是一个周期的时间(一个周期里浏览所有的图片才结束一个周期),

scheduledTimerWithTimeInterval:(NSTimeInterval)seconds  
预订一个Timer,设置一个时间间隔。
表示输入一个时间间隔对象，以秒为单位，一个>0的浮点类型的值，如果该值<0,系统会默认为0.1,即执行选择器中的方法一次周期时间,
userInfo:(id)userInfo
此参数可以为nil，当定时器失效时，由你指定的对象保留和释放该定时器。
repeats:(BOOL)yesOrNo

当YES时，定时器会不断循环直至失效或被释放，当NO时，定时器会循环发送一次就失效(即要执行的语句实现以后)。
invocation:(NSInvocation *)invocation

   //    imageView.userInteractionEnabled = YES;
    //    imageView.hidden = YES;

//设置UIImage的渲染模式：UIImage.renderingMode
tabBarItem.selectedImage=[[UIImage imageNamed:imageArray[i]]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];

设置UIImage的渲染模式：UIImage.renderingMode
着色（Tint Color）是iOS7界面中的一个重大改变，你可以设置一个UIImage在渲染时是否使用当前视图的Tint Color。UIImage新增了一个只读属性：renderingMode，对应的还有一个新增方 法：imageWithRenderingMode:，它使用UIImageRenderingMode枚举值来设置图片的renderingMode属 性。该枚举中包含下列值：
	1	UIImageRenderingModeAutomatic // 根据图片的使用环境和所处的绘图上下文自动调整渲染模式。 
	2	UIImageRenderingModeAlwaysOriginal // 始终绘制图片原始状态，不使用Tint Color。 
	3	UIImageRenderingModeAlwaysTemplate // 始终根据Tint Color绘制图片，忽略图片的颜色信息。 
renderingMode属性的默认值是UIImageRenderingModeAutomatic，即UIImage是否使用Tint Color取决于它显示的位置。其他情况可以看下面的图例

frame                                                 坐标
center                                               中心点
bounds (也可以用于window里求边框大小)边框大小
backgroundColor                             背景颜色
tag                                                     标签
hidden                                           隐藏(隐藏后 隐藏的位置就空出来了)
contentMode                                   内容模式
alpha                                                  透明度(0-1)
autosizesSubviews                       子类自动布局
transform                                    可以通过这个属性控制视图的放大缩小和旋转
superview                                     获取父视图
subviews                                       获取所有子视图
userIntercationEnabled               是否响应用户交互事件
[self.view endEditing:YES];     //设置是否取消view上所有的编辑状态
tintColor                                 //设置高亮颜色()

UIVewController的另一个功能是处理用户交互操作，注意这里我说的是"处理"，当然UIViewController本身是不知道用户交互的，这就需要UIView将用户的交互操作(例如:touchesBegintouchesMoved)传递上来。

//1。交换两个子视图的位置
    //[self.view exchangeSubviewAtIndex:2 withSubviewAtIndex:3];
    
    //2.将子视图显示到最上面
    //[self.view bringSubviewToFront:view];
    
    //3.将子视图放到最下面
    //[self.view sendSubviewToBack:view4];


UIView  *view1,view2,view3
        [self.window addSubview:view1];
        [view1 addSubview:view2];
        [view1 addSubview:view3];
那么,view1是view2,view3的父类视图,
view=view2.superview//用于取父类视图,取到以后可以对其进行操作

NSArray *subViews=view1.subviews;//得到子类视图数组
NSLog(@“count=%d”,subViews.count);

UIview *view=[subViews objectAtIndex:0]//用于取得数组中每一个位置的姿势图

contentMode属性：
这个属性是用来设置图片的显示方式，如居中、居右，是否缩放等
以上几个常量，凡是没有带Scale的，当图片尺寸超过 ImageView尺寸时，只有部分显示在ImageView中。UIViewContentModeScaleToFill属性会导致图片变形。UIViewContentModeScaleAspectFit会保证图片比例不变，而且全部显示在ImageView中，这意味着ImageView会有部分空白。UIViewContentModeScaleAspectFill也会证图片比例不变，但是是填充整个ImageView的，可能只有部分图片显示出来。



//自动布局
UIView *backView,topView;
//父类准许子类View自动布局backView.autoresizesSubviews=YES;
[self.window addSubeview:backView]
//子类设置自动布局方式topView.autosizingMark=UIViewAutoresizingFlexibleWidth;
[backView addSubeview:topView]

//看布局效果(记主要把父类视图设成全局变量)
[NSTimer scheduledTimerWithInterval:0.5 target:self   selector:@selector (timeTick)userInfo:nil  repeats:YES];
-(void )timeTick
{
    _backView.frame=CgRectMake(_backView.frame.origin.x,y,width+5,height+5);
}

对window上添加视图,可以一层一层叠加,最开始的,在最底层,最近的是最高层
//设置一个试图控制器为主视图控制器
    self.window.rootViewController=mvc

UIView的transform属性就是一个CGAffineTransform类型的数据,默认值为CGAffineTransformIdentity。
@property(nonatomic) CGAffineTransform transform
UIView *square;
//Translate
CGAffineTransform transform = CGAffineTransformMakeTranslation(60, 140);
//Scale
transform = CGAffineTransformScale(transform, 0.5, 0.5);
//Rotate旋转
//_angle-=M_PI_4;
transform = CGAffineTransformRotate(transform, radians(60));
[square setTransform:transform];

[control setModalTransitionStyle:UIModalTransitionStyleCrossDissolve];
    //Modal模式的,Transition过渡转换,Cross交叉的,Dissolve
[self presentViewController:control animated:YES completion:^{}];
//animated跳转,动画,completion结束

//关闭模式对话窗体
 //[self dismissViewControllerAnimated:YES completion:^{}];

视图控制器,可以先设置其视图view以便于,可以直观的感受到

视图切换到另一个另一个视图,可以设置其切换模式,然后切换


添加控件的时候注意先后顺序,先进的在底层,后加的在顶层.frame够大的时候,会覆盖掉底层的.

记住,不管你什么时候,加视图控制器,它都会加在最低层,且在window的上面,因此以后写程序,尽量先写视图控制器,再视图,再控件


self.hidesBottomBarWhenPushed=YES;
 [self.navigationController pushViewController:subVC animated:YES];
self.hidesBottomBarWhenPushed=NO;




+(void)当不需要类方法




frame
backgroundColor
titleLabel.font(虽然UIButton的titleLabel属性是readOnly,但是可以通过titleLabel来设置font等等)
btn setSelected:<#(BOOL)#>//设置是否选中,跟点击手势效果相同
btn.titleLabel.adjustsFontSizeToFitWidth=YES;//自适应字体尺寸大小
contentHorizontalAlignment
contentEdgeInsets
showsTouchWhenHighLighted
adjustsImageWhenHighlighted(BOOL类型)   设置高亮状态下按钮变暗(一定要是图片)

button的响应事件要写在和响应方法在同一个类里面,不能封装在其它类里面,否则报错
+(id)buttonWithType:(UIButtonType)buttonType;//类方法
10.UIButtonTypeRoundRect被UIButtonTypeSystem取代了
方法
初始化:UIBotton *b t n=[UIBotton buttonWithType:UIControlTypeRoundRect]
设置属性frame:
           bt n.frame=CGRectMake{x,y,width,height};
设置属性backgroundColor
设置按钮上字
           [bt n  setTitle:@“字符串”  forState:UIControlStateNormal];
//@property(nonatomic,readonly,retain) UILabel     *titleLabel
       button.titleLabel.text=@"移动";//这样不能实现文本,因为readonly
———————————-setImage——————————————-
           [bt n  setTitle:@“字符串”  forState:UIControlStateHighlighted];
设置字体颜色
          bt n.t i tile Label.font=[UIColor redColor];
设置高亮状态下背景的颜色
         [ bt n   setTintColor :[UIColor brownColor]];
设置高亮状态下是否发光(BOOL类型)
      bt n.showsTouchWhenHighLighted=YES

设置字体的对齐方式

默认文字会紧贴到做边框,我们可以设置(contentEdge边缘Insets)
bt n.contentEdgeInsets=UIEdgeInsetsMake(0,10,0,0);
bt n.imageEdgeInsets
bt n.titleEdgeInsets

图片作为按钮的背景的时候,会被拉伸充满整个按钮区域
UIImage *image=[UIImage imageNamed:@"6.JPG"];
    UIImageView *imageView=image;
    [btn setBackgroundImage:image forState:UIControlStateNormal];
将图片设置成按钮上的图片(图片不会被拉伸)
[bt n  setImage:image forState:UIControlStateNormal];

//UIButton继承UIControl,此外只要用赋值的,其值都是以UIControl开头的



//   button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentCenter;//设置button的内容横向居中。。设置content是title和image一起变化
 button.titleEdgeInsets = UIEdgeInsetsMake(71, -button.titleLabel.bounds.size.width-50, 0, 0);//设置title在button上的位置（上top，左left，下bottom，右right）

button4.layer.cornerRadius=10;//圆角半径
    button4.layer.masksToBounds=YES;//修剪成圆角,把圆角外的裁剪出去

 //修改图片位置
    button4.imageEdgeInsets=UIEdgeInsetsMake(80, 60, 20, 0);
    //UIEdgeInsets insets = {top, left, bottom, right};
// {top是图片或者文字的左上端距离button的上端的位置, left, bottom, right};它表示的是内容与控件边界的距离
//如果同时设置top,bottom的时候,top+bottom+图片的高度要小于等于控件的高度,当大于控件高度的时候,图片会被压扁,或者拉伸(这是在底层内部实现的,看不到是如何实现的)
//只看到UIButton可以设置Insets，对应的属性是：contentEdgeInsets、titleEdgeInsets、imageEdgeInsets，
    //修改文字的位置
    button4.titleEdgeInsets=UIEdgeInsetsMake(20, -60, 0, -75);

[btn setTintColor:[UIColor blackColor]];//这种方法不能够实现,可以使用下面的方法[btn setTitleColor:[UIColor blackColor] forState:UIControlStateHighlighted];

@property(nonatomic)          BOOL         adjustsImageWhenHighlighted;   
 // default is YES. if YES, image is drawn darker when highlighted(pressed)通过一个label显示一个整型变量，后每按一次button，label中的数字都会加1
-(void)buttonClicked

{
     label.text = [NSString stringWithFormat:@"%d",[label.text intValue]+1];
————————————————————  以下实现点击label,替换图片————————————————
NSString *str=[NSString stringWithFormat:@"%d.jpg",[_label.text intValue]+1];
    UIColor *color=[UIColor colorWithPatternImage:[UIImage imageNamed:str]];
    _label.backgroundColor=color;

}
int val=[label.text intValue];//NSString到 intValue的转换
int _time=1;(点击一次Button,_time在下面的语句自动加1)
在UI里,可以把整个点击事件看成OC中的无限死循环,
-(void)buttonBlick
{
    //_button.titleLabel.text=[NSString stringWithFormat:@"%d",[_button.titleLabel.text intValue]+1];
    //button的titlleLabel只可读
    _time++;
    UIImage *image=[UIImage imageNamed:[NSString stringWithFormat:@"%d.jpg",_time]];
    UIImageView *imageView=[[UIImageView alloc]initWithImage:image];
    imageView.frame=CGRectMake(0, 20, 360, 30);
    [_button addSubview:imageView];
}


(CGRect)titleRectForContentRect:(CGRect)contentRect;//这个可以改变button上面的Label的frame,contentRect就是整个UIButton的bounds,然后设置的title的frame,是根据title将要显示在button上的frame来返回
-button.titleEdgeInsets
(CGRect)imageRectForContentRect:(CGRect)contentRect;
/这个可以改变button上面的imageView的frame
button4.imageEdgeInsets

- (void)viewDidLoad
{
    [super viewDidLoad];
    super.view.backgroundColor=[UIColor purpleColor];
    
}

只能在UIControlView上进行操作,相当于画画必须在画板上操作一样
没有frame,backgroundColor等属性


@property(nonatomic,readonly,retain) UINavigationController *navigationController; // If this view controller has been pushed onto a navigation controller, return it.
//这是UINavigationController中对UIViewController的扩展,但是仅仅是可读的

@property(nonatomic) BOOL hidesBottomBarWhenPushed;
@property(nonatomic,readonly,retain) UINavigationItem *navigationItem;


@interface UIViewController (UITabBarControllerItem)//UIViewController的扩展

@property(nonatomic,retain) UITabBarItem *tabBarItem; // Automatically created lazily with the view controller's title if it's not set explicitly.

@property(nonatomic,readonly,retain) UITabBarController *tabBarController; // If the view controller has a tab bar controller as its ancestor, return it. Returns nil otherwise.

@end

通过NSTimer看IPhone对@selector的函数如何传参数
NSMutableDictionary *dict = [[NSMutableDictionary alloc] init];  
    if(oldView != nil)
    {
        [dict setObject:oldView forKey:@"oldView"]; 
    }
    if(newView != nil)
    {
        [dict setObject:newView forKey:@"newView"]; 
    } 
    [NSTimer scheduledTimerWithTimeInterval:0.0 target:self selector:@selector(onTimer:) userInfo:dict repeats:NO];  
    [dict release];
 
 
- (void)onTimer:(NSTimer *)timer 
{  
    UIView *oldView = [[timer userInfo] objectForKey:@"oldView"];
    UIView *newView = [[timer userInfo] objectForKey:@"newView"];  
    [UIView animateWithDuration:2.0  delay:0
                        options:UIViewAnimationOptionAllowUserInteraction
                     animations:^{  
                         oldView.alpha = 0.0; 
                         newView.alpha = 1.0;  
                     }  
} 

从上可以看出，NSTimer在对@selector(onTimer:)传递参数时，将传参的对象储存在了NSTimer的userInfo的字典里，在- (void)onTimer:(NSTimer *)timer中
通过取出该字典加以使用。
这个其实也就是iphone对@selector对象传参的通用的形式。


[btn2 addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchUpInside];
-(void)btnClick:(id)Senter;这样不传参数也是可以的
{
    UIButton *button=(UIButton *)Senter;
    if(button.tag==1)
    {
        [_imageView startAnimating];
    }
    if(button.tag==2)
    {
        [_imageView stopAnimating];
    }
}

3、监听UISwitch按下事件
实现代码如下：

-(void)switchAction:(id)sender
{
    UISwitch *switchButton = (UISwitch*)sender;
    BOOL isButtonOn = [switchButton isOn];
    if (isButtonOn) {
        showSwitchValue.text = @"是";
    }else {
        showSwitchValue.text = @"否";
    }
}

textfield是单行文本啊 
UITextField 是UIControl的子类,UIControl又是UIView的子类,所以也是一个视图,只不过比UIView多了两个功能,1.文字显示,2.文本编辑 
使用过程分四步: 
1.创建对象 
2.配置属性 
3添加到父视图 
4.释放所有权 
1.创建对象 
UITextField *text = [[UITextField alloc] initWithFrame:CGRectMake(50, 50, 180, 50)]; text.backgroundColor = [UIColor yellowColor]; [_view addSubview:text]; [text release];
2.设置text的边框样式(圆角) 
text.borderStyle = UITextBorderStyleRoundedRect; 
3.设置text默认显示文字(但是不作为文本内容的一部分) 
text.placeholder = @"请输入用户名"; 
4.设置text文字 
text.text = @"什么破烂”;
5.设置文本颜色 
text.textColor = [UIColor blackColor];
6.设置文本的对齐方式 
text.textAlignment = NSTextAlignmentCenter;
7.设置文字字体 
text.font = [UIFont systemFontOfSize:18]; 
8.设置输入框是否可编辑 
text.enabled = YES;
9.设置当开始编辑时,是否清除框中内容 
text.clearsOnBeginEditing = YES; 
10.设置密码格式(输入框中内容是否以点的形式显示) 
text.secureTextEntry = YES; 
11.设置弹出键盘的样式(数字键盘) 
text.keyboardType = UIKeyboardTypeNumberPad; 
12.键盘右下角显示样式 
text.returnKeyType = UIReturnKeyGo;
12.@property(nonatomic,retain) UIImage                *background;  设置背景图片
13.设置tag值
text.tag = 120;
14.键盘回收

1.点击右下角或者回车回收键盘
1.设置代理
text.delegate = self;

2.服从协议
在相应.h文件添加协议,如
@interface MAYAppDelegate : UIResponder <UIApplicationDelegate,UITextFieldDelegate>
服从,<UITextFieldDelegate>协议

3.实现协议中的方法
- (BOOL)textFieldShouldReturn:(UITextField *)textField
{ 
回收键盘,取消第一响应者 
[textField resignFirstResponder]; return YES;
}
2.点击空白处回收键盘
1.设置代理
text.delegate = self;

2.服从协议
在相应的.h文件中添加协议,如
@interface MAYAppDelegate : UIResponder <UIApplicationDelegate,UITextFieldDelegate>
服从,<UITextFieldDelegate>协议

3.实现协议中的方法
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event { 
[text resignFirstResponder]; 
} 
UITextField通过成为和放弃第一响应者来呼出和关闭键盘
[txtAccount resignFirstResponder];
[txtAccount becomeFirstResponder];

textField.text=@"大头儿女子";设置初始文本框的内容


//—————————————获取输入内容—————————————
可以通过UITextField的delegate方法来获取
- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string
{
    NSString *text = [textField.text stringByReplacingCharactersInRange:range withString:string];
    return YES;
}
但是今天发现了在iOS7上如果当输入中文的时候，到最后只会识别到的只是拼音的字符串，而不是最后的中文。如“你好”，最后只会是nihao。我们可以通过以下的方法来获取
 [textField addTarget:self action:@selector(textFieldEditChanged:) forControlEvents:UIControlEventEditingChanged];
//用该方法可以,当UITextField中的text内容有改变的时候,就调用该方法,传入一个textField,可以对其属性读取操作(相当于死循环,改变一次就调用一次方法
添加输入改变的方法
- (void)textFieldEditChanged:(UITextField *)textField
{
	    NSLog(@"textfield text %@",textField.text);

}

//-=====————————自动使用内容高度—————————————
[textField addTarget:self action:@selector(autoHeightByText:) forControlEvents:UIControlEventEditingChanged];
_textView.frame=CGRectMake(0, 30, 360, _textView.contentSize.height);
一、UITextField手动编写控件

UITextField  *txtAccount = [[UITextField alloc] initWithFrame:CGRectMake(10, 10, 300, 30)];
    
    // 设置委托
    [txtAccount setDelegate:self];
    // 设置占位符
    [txtAccount setPlaceholder:@"账号"];
    // 设置文本对齐
    [txtAccount setTextAlignment:NSTextAlignmentLeft];
    // 设置样式
    [txtAccount setBorderStyle:UITextBorderStyleRoundedRect];
    // 加入view中
    [self.view addSubview: txtAccount];
    [txtAccount release];

二、UITextFieldDelegate委托

// 设置输入框，是否可以被修改
// NO-将无法修改，不出现键盘
// YES-可以修改，默认值 
- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField{
    return YES;

}

// 当点击键盘的返回键（右下角）时，执行该方法。
// 一般用来隐藏键盘
- (BOOL)textFieldShouldReturn:(UITextField *)textField{
    if (txtAccount == textField) {
[txtAccount resignFirstResponder];
}
return YES;
}

// 当输入框获得焦点时，执行该方法。 
- (void)textFieldDidBeginEditing:(UITextField *)textField{
    NSLog(@"textFieldDidBeginEditing");

}

// 指定是否允许文本字段结束编辑，允许的话，文本字段会失去first responder 
- (BOOL)textFieldShouldEndEditing:(UITextField *)textField{
    return YES;

}

// 文本框失去first responder 时，执行 
- (void)textFieldDidEndEditing:(UITextField *)textField{
     NSLog(@"textFieldDidEndEditing");

}

 
// 指明是否允许根据用户请求清除内容
- (BOOL)textFieldShouldClear:(UITextField *)textField{
    NSLog(@"textFieldDidEndEditing");
    return YES;
}

// 文本框的文本，是否能被修改 
- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string{
    return YES;

} 
改变UITextField placeHolder颜色、字体
分类： iphone基本应用
2012-09-27 15:28 7791人阅读 评论(2) 收藏 举报
图形button
我们有时需要定制化UITextField对象的风格，可以添加许多不同的重写方法，来改变文本字段的显示行为。这些方法都会返回一个CGRect结构，制定了文本字段每个部件的边界范围，甚至修改placeHolder颜色，字体。

– textRectForBounds:　　    //重写来重置文字区域
– drawTextInRect:　　       //改变绘文字属性.重写时调用super可以按默认图形属性绘制,若自己完全重写绘制函数，就不用调用super了.
– placeholderRectForBounds:　　//重写来重置占位符区域
– drawPlaceholderInRect:　　//重写改变绘制占位符属性.重写时调用super可以按默认图形属性绘制,若自己完全重写绘制函数，就不用调用super了
– borderRectForBounds:　　//重写来重置边缘区域
– editingRectForBounds:　　//重写来重置编辑区域
– clearButtonRectForBounds:　　//重写来重置clearButton位置,改变size可能导致button的图片失真
– leftViewRectForBounds:
– rightViewRectForBounds:

通过– drawPlaceholderInRect:方法可改变placeHolder颜色、字体，请看代码：
首先定义一个类CustomTextField让它继承UITextField实现以下方法即可：
//控制清除按钮的位置
-(CGRect)clearButtonRectForBounds:(CGRect)bounds
{
   return CGRectMake(bounds.origin.x + bounds.size.width - 50, bounds.origin.y + bounds.size.height -20, 16, 16);
}

//控制placeHolder的位置，左右缩20
-(CGRect)placeholderRectForBounds:(CGRect)bounds
{
    
    //return CGRectInset(bounds, 20, 0);
   CGRect inset = CGRectMake(bounds.origin.x+100, bounds.origin.y, bounds.size.width -10, bounds.size.height);//更好理解些
   return inset;
}
//控制显示文本的位置
-(CGRect)textRectForBounds:(CGRect)bounds
{
    //return CGRectInset(bounds, 50, 0);
    CGRect inset = CGRectMake(bounds.origin.x+190, bounds.origin.y, bounds.size.width -10, bounds.size.height);//更好理解些
    
    return inset;

}
//控制编辑文本的位置
-(CGRect)editingRectForBounds:(CGRect)bounds
{
    //return CGRectInset( bounds, 10 , 0 );
    
   CGRect inset = CGRectMake(bounds.origin.x +10, bounds.origin.y, bounds.size.width -10, bounds.size.height);
   return inset;
}
//控制左视图位置
- (CGRect)leftViewRectForBounds:(CGRect)bounds
{
   CGRect inset = CGRectMake(bounds.origin.x +10, bounds.origin.y, bounds.size.width-250, bounds.size.height);
   return inset;
    //return CGRectInset(bounds,50,0);
}

//控制placeHolder的颜色、字体
- (void)drawPlaceholderInRect:(CGRect)rect
{
    //CGContextRef context = UIGraphicsGetCurrentContext();
    //CGContextSetFillColorWithColor(context, [UIColor yellowColor].CGColor);
    [[UIColororangeColor] setFill];
    
    [[selfplaceholder] drawInRect:rectwithFont:[UIFontsystemFontOfSize:20]];
}


//下面是使用CustomTextField的代码，可放在viewDidLoad等方法中
    _textField = [[CustomTextField alloc] initWithFrame:CGRectMake(20, 150, 280, 30)];
    _textField.placeholder = @"请输入帐号信息";
    _textField.borderStyle = UITextBorderStyleRoundedRect;
    _textField.textAlignment = UITextAlignmentLeft;
    _textField.delegate = self;
    _textField.clearButtonMode = UITextFieldViewModeWhileEditing;
    _textField.text = @"aa";
    UIImageView *imgv = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"icon-iwant-2.png"]];
    _textField.leftView = imgv;
    _textField.leftViewMode = UITextFieldViewModeAlways;
    [self.view addSubview:_textField];

_textField.inputAccessoryView,会跟着虚拟键盘一起升起,并且存在键盘上部
_textField.inputView这个推出视图是在_textFiled的最底部

可以设置多行输入文本
当用UITextView仅仅显示文本的时候,可以设置userInteractionEnabled=NO;

UIKit提供了一组控件：UISwitch开关、UIButton按钮、UISegmentedControl分段控件、UISlider滑块、UITextField文本字段控件、
UIPageControl分页控件。

控件是对UIView派生类的实用增强及补充，并可以直接附着于导航栏、表格单元，甚至更大的对象。

这些控件的基类均是UIControl，而UIControl派生自UIView类，所以每个控件都有很多视图的特性，包括附着于其他视图的能力。所有
控件都拥有一套共同的属性和方法。
所以学习控件，我们先学习UIControl



属性

enabled
控件默认是启用的。要禁用控件，可以将enabled属性设置为NO，这将导致控件忽略任何触摸事件。被禁用后，控件还可以用不同的方式显示自己，比如变成灰色不可用。虽然是由控件的子类完成的，这个属性却存在于UIControl中。

selected
当用户选中控件时，UIControl类会将其selected属性设置为YES。子类有时使用这个属性来让控件选择自身，或者来表现不同的行为方式。

contentVerticalAlignment
控件如何在垂直方向上布置自身的内容。默认是将内容顶端对其，对于文本字段，可能会改成UIControlContentVerticalAlignmentCenter。对于这个字段，可以使用下列诸值：
1.
UIControlContentVerticalAlignmentCenter  
2.
UIControlContentVerticalAlignmentTop  
3.
UIControlContentVerticalAlignmentBottom  
4.
UIControlContentVerticalAlignmentFill
 
contentHorizontalAlignment
水平方向
1.
UIControlContentHorizontalAlignmentCenter  
2.
UIControlContentHorizontalAlignmentTop  
3.
UIControlContentHorizontalAlignmentBottom  
4.
UIControlContentHorizontalAlignmentFill  

事件通知

UIControl类提供了一个标准机制，来进行事件登记和接收。这令你可以指定你的控件在发生特定事件时，通知代理类的一个方法。如果要注册一个事件，可以使用addTarget方
法：
[ myControl addTarget: myDelegate   action:@selector(myActionmethod:)  forControlEvents:UIControlEventValueChanged ];
事件可以用逻辑OR合并在一起，因此可以再一次单独的addTarget调用中指定多个事件。下列事件为基类UIControl所支持，除非另有说明，也适用于所有控件

UIControlEventTouchDown
单点触摸按下事件：用户点触屏幕，或者又有新手指落下的时候。

UIControlEventTouchDownRepeat
多点触摸按下事件，点触计数大于1：用户按下第二、三、或第四根手指的时候。

UIControlEventTouchDragInside
当一次触摸在控件窗口内拖动时。

UIControlEventTouchDragOutside
当一次触摸在控件窗口之外拖动时。

UIControlEventTouchDragEnter
当一次触摸从控件窗口之外拖动到内部时。

UIControlEventTouchDragExit
当一次触摸从控件窗口内部拖动到外部时。

UIControlEventTouchUpInside
所有在控件之内触摸抬起事件。

UIControlEventTouchUpOutside
所有在控件之外触摸抬起事件(点触必须开始与控件内部才会发送通知)。

UIControlEventTouchCancel
所有触摸取消事件，即一次触摸因为放上了太多手指而被取消，或者被上锁或者电话呼叫打断。

UIControlEventTouchChanged
当控件的值发生改变时，发送通知。用于滑块、分段控件、以及其他取值的控件。你可以配置滑块控件何时发送通知，在滑块被放下时发送，或者在被拖动时发送。

UIControlEventEditingDidBegin
当文本控件中开始编辑时发送通知。

UIControlEventEditingChanged
当文本控件中的文本被改变时发送通知。

UIControlEventEditingDidEnd
当文本控件中编辑结束时发送通知。

UIControlEventEditingDidOnExit
当文本控件内通过按下回车键（或等价行为）结束编辑时，发送通知。

UIControlEventAllEditingEvents
通知所有关于文本编辑的事件。

UIControlEventAllEvents
通知所有事件。

要删除一个或多个事件的相应动作，可以使用UIControl类的removeTarget方法。使用nil值就可以将给定事件目标的所有动作删除：
[ myControl removeTarget:myDelegate   action:nil  forControlEvents:UIControlEventAllEvents];
  
要取得关于一个控件所有指定动作的列表，可以使用allTargets方法。这个方法返回一个NSSet，其中包含事件的完整列表：
NSSet* myActions = [myConreol allTargets ];  

另外，你还可以用actionsForTarget方法，来获取针对某一特定事件目标的全部动作列表：
NSArray* myActions = [ myControl actionForTarget:UIControlEventValueChanged ];  

如果设计了一个自定义控件类，可以使用sendActionsForControlEvent方法，为基本的UIControl事件或自己的自定义事件发送通知。例如，如果你的控件值正在发生变化，就可以
发送相应通知，通过控件的代码可以指定时间目标，这个通知将被传播到这些指定的目标。例：
[ self sendActionsForControlEvents:UIControlEventValueChanged ]; 

当委托类得到事件通知时，他将收到一个指向事件发送者的指针。下面的例子用于处理分段控件的事件，你的动作方法（action method）应遵循类似的处理方式：
-(void) myAction:(id)sender{  
       UISegmentedControl* control = (UISegmentedControl*)sender;  
       if(control == myControl1){  
       /*查询控件得值*/  
      /*响应myControl1的动作*/  
       }  
}  

使用  NSTimer scheduledTimerWithTimeInterval: target: selector:userInfo: repeats: 的时候有两个地方需要注意 。
首先selector指定的方法必须是带一个参数的方法，并且那个参数的类型是NSTimer *。举个例子
[NSTimer scheduledTimerWithTimeInterval:0.5 
                       target:self 
                       selector:@selector(sendBroadcast:) 
                       userInfo:@"hello I'm the info to send" 
                       repeats:NO];
sendBroadcast的定义形式应该是
-(void)sendBroadcast: (NSTimer *)timer { 

}
其次，参数是靠NSTimer 对象的userInfo属性来传递的。

-(void)sendBroadcast: (NSTimer *)timer { 
    NSString *msg = (NSString *)[timer userInfo]; // [msg isEqualToString @"hello I'm the info to send"] == YES
} 

scheduledTimerWithTimeInterval:(NSTimeInterval)seconds  
预订一个Timer,设置一个时间间隔。
表示输入一个时间间隔对象，以秒为单位，一个>0的浮点类型的值，如果该值<0,系统会默认为0.1,即执行选择器中的方法一次周期时间,
 target:(id)aTarget
表示发送的对象，如self
 selector:(SEL)aSelector
方法选择器，在时间间隔内，选择调用一个实例方法
userInfo:(id)userInfo
此参数可以为nil，当定时器失效时，由你指定的对象保留和释放该定时器。
repeats:(BOOL)yesOrNo

除了控制一些控件的属性自加一位,还可以自己写方法
- (void)setProgress:(float)progress
{
    _progerssTemp+=0.5;(进度条的值)
}
自己写的方法用时间器控制
 [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(viewLyrics:) userInfo:nil repeats:YES];
//repeats设置为YES,不退出死循环,无限执行下面的方法
-(void)viewLyrics:(id)sender
{
    if(_temp<[_lyrics count])注意这里,当条件成立时才执行括号内的语句,不成立时仅仅只进入方法,执行括号外的语句,但是括号外什么语句也没有,就什么也不执行,使时间器进入死循环
    {
    [_str appendString:[_lyrics objectAtIndex:_temp++]];
    
    _text.text=[NSString stringWithFormat:@"%@",_str];
   _text.textColor=[UIColor whiteColor];
//------------------------自适应高度,却不能自适应宽度-----------------
    //_text.frame=CGRectMake(0, 0, _text.contentSize.width, _text.contentSize.height);
    _text.frame=CGRectMake(0, 0, 355, _text.contentSize.height);
    }
注意这里
}

每个视图控制器都有一个navigationItem属性
每个视图控制器都可以通过navigationItem属性来定制导航栏的显示
NavigationItem在navigation Bar代表一个viewController，具体一点儿来说就是每一个加到navigationController的viewController都会有一个对应的navigationItem，该对象由viewController以懒加载的方式创建，稍后我们可以在对象中堆navigationItem进行配置，可以设置leftBarButtonItem, rightBarButtonItem, backBarButtonItem, title以及prompt等属性。前三个每一个都是一个UIBarButtonItem对象，最后两个属性是一个NSString类型描述，注意添加该描述以后NavigationBar的高度会增加30，总的高度会变成74(不管当前方向是Portrait还是Landscape，此模式下navgationbar都使用高度44加上prompt30的方式进行显示)。当然如果觉得只是设置文字的title不够爽，你还可以通过titleview属性指定一个定制的titleview，这样你就可以随心所欲了，当然注意指定的titleview的frame大小，不要显示出界。

用setTitle方法设置导航栏UINavigationItem的文本,应大大大大该是视图控制器取UIViewController调用,而不是UINavigationController调用

	//把导航栏集合添加入导航栏中，设置动画关闭 (须先创建导航栏)
 [navigationBar pushNavigationItem:navigationItem animated:NO]; 
还有一种当在已经创建UINavigationController下,用点语法,可以直接取设置属性
navigation.navigationBar      ,        [_control.navigationItem setRightBarButtonItem:rightButton];  _control.navigationItem,
但是前提条件是你得先创建一个导航控制器.(设置UINavigationController的属性都不要用导航控制器去调用,而是用导航控制器当前所在的视图控制器或者视图去调用)
//另外可以创建一个导航栏把它直接加到视图View或者Window里再把(UINavigationItem...UIBarButtonItem)加入到导航栏中
而(UINavigationItem...UIBarButtonItem)不是加到导航器中,
//创建了UINavigationController就不需要再创建UINavigationBar,因为导航控制器自带导航栏,可以通过UINavigationController.navigationBar去设置导航器自带的frame,backgroundImage等等

加入的顺序:
UINavigationController—->UINavigationBar——>UINavigationItem——>UIBarButtonItem

[_navigation pushViewController:twoController animated:YES];往导航控制器加入视图控制器,并且使界面跳转到该界面去

导航栏只要在一个试图控制器上进行修改后,所有的视图试图控制器上的导航栏都进行相应的改动


设置导航条的背景颜色会影响tableView的frame

UINavigationBar上的属性都要通过UINavigationItem调用

//修改了UIBarButtonItem上面按钮的颜色 
    self.navigationController.navigationBar.tintColor=[UIColor redColor];

UIToolBar可以通过UIBarButtonItem来设置样式,因为UIBarBUttonItem继承自View,因此可以在UItoolBar上设置视图,
self.navigationController.toolbarHidden=NO;
    self.navigationController.toolbar.barStyle=UIBarStyleBlackTranslucent;
    self.navigationController.toolbar.backgroundColor=[UIColor blueColor];

//设置文字
    //设置导航控制器title属性会影响tabBarItem.title的值
    secondNavCtrl.title = @"second";
    //设置secondCtrl.title影响tabBarItem.title的值和navigationItem.title的值
    secondCtrl.title = @“第二个";


self.navigationItem.hidesBackButton=YES;//隐藏返回按钮
- (void)setHidesBackButton:(BOOL)hidesBackButton animated:(BOOL)animated;//隐藏加动画
navigationItem.backBarButtonItem设置返回按钮属性

.navigationItem.titleView(自定义的视图)设置与self.navigationItem.title(文字,但不可以改变样式)=@“百度”对应的UINavigationBar中间的显示,
navigationItem的背景颜色是通过navigationBar来设置.但是它只能设置样式和背景


 //背景图片
    [self.navigationController.navigationBar setBackgroundImage:[UIImage imageNamed:@"bar_bj.png"] forBarMetrics:UIBarMetricsDefault];
//navigationItem title的颜色
    NSDictionary *navTitleArr = [NSDictionary dictionaryWithObjectsAndKeys:[UIColor whiteColor],NSForegroundColorAttributeName,nil];
    self.navigationController.navigationBar.titleTextAttributes = navTitleArr;

[[UIBarButtonItem alloc]initWithCustomView:btn]通过该方法设置UINavigationItem左右边自定义Item按钮的时候,btn的frame可以不设置x,y值,只需设置bounds




_label = (UILabel *)self.navigationItem.titleView;
只有这样才能对navigationItem的titleView显示文字改掉,要先取出label再设置
左右itemButton也是要取出来,才能设置如果你自己写类继承自UITabBarViewController,那么它在作为window的根视图的时候就不需要再加入UINavigationController了,因为它具有navigationController属性本身在创建的时候就创建,并加入了自身的navigationController了


//创建TabBarController
    NSArray *nameArray = @[@"首页",@"周边",@"搜索",@"我的"];
    NSArray *imageArray = @[@"main.png",@"around.png",@"search.png",@"myManzuo.png"];
    NSArray *ctrlArray = @[@"HomePageController",@"NearbyController",@"SearchViewController",@"MineViewController"];
    NSMutableArray *array = [NSMutableArray array];
    for(int i=0 ; i<nameArray.count ; i++)
    {
        Class cls = NSClassFromString(ctrlArray[i]);
        UIViewController *vc=[[cls alloc]init];
        vc.tabBarItem.title = nameArray[i];
        vc.tabBarItem.image = [UIImage imageNamed:imageArray[i]];
        UINavigationController *nav = [[UINavigationController alloc]initWithRootViewController:vc];
        [array addObject:nav];
    }
    UITabBarController *tabBar = [[UITabBarController alloc]init];
    tabBar.viewControllers = array;
    self.window.rootViewController = tabBar;

视图控制器通过UINavigationController来push出视图,被推出的视图,仅仅第一次加载了viewDidload方法,后面都不会加载,仅仅加载viewWillAppear等等方法


ReduceViewController *reduceCtrl = [[ReduceViewController alloc]init];
    reduceCtrl.tabBarItem.title = @"降价";
    reduceCtrl.tabBarItem.image = [[UIImage imageNamed:@"tabbar_reduceprice.png"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
    reduceCtrl.tabBarItem.selectedImage = [[UIImage imageNamed:@"tabbar_reduceprice_press.png"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
    UINavigationController *reduceNav = [[UINavigationController alloc]initWithRootViewController:reduceCtrl];-(void)rightClick:(id)sender
{
    [self showDialog:@"点击了导航栏左边按钮"];
}
//----------------------------添加弹出框-------------------------
-(void)showDialog:(NSString *)string
{
    UIAlertView *alert=[[UIAlertView alloc]initWithTitle:@"这是一个对话框" message:string delegate:self cancelButtonTitle:@"确定" otherButtonTitles:nil];
    [alert show];
    //[alert release];
}

//当AlertView上的确定按钮被点击时,调用
- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex

CGSize contentSize ：设置UIScrollView的滚动范围
(如果contentSize的height设置为0就代表不能竖直方向上移动)
CGPoint contentOffset ：UIScrollView当前滚动的位置
UIEdgeInsets contentInset ：这个属性可以在四周增加滚动范围

BOOL bounces 是否有弹簧效果
BOOL scrollEnabled 是否能滚动
BOOL showsHorizontalScrollIndicator 是否显示水平方向的滚动条
BOOL showsVerticalScrollIndicator     是否显示垂直方向的滚动条
UIScrollViewIndicatorStyle indicatorStyle  设定滚动条的样式
BOOL dragging 是否正在被拖拽
BOOL tracking  当touch后还没有拖动的时候值是YES，否则NO
BOOL decelerating 是否正在减速
BOOL zooming 是否正在缩放

手势缩放
设置UIScrollView的id<UISCrollViewDelegate> delegate代理对象
设置minimumZoomScale ：缩小的最小比例
设置maximumZoomScale ：放大的最大比例
让代理对象实现下面的方法，返回需要缩放的视图控件
- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView
跟缩放相关的常用方法还有
正在缩放的时候调用
-(void)scrollViewDidZoom:(UIScrollView *)scrollView
缩放完毕的时候调用
-(void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(UIView *)view atScale:(float)scale

页效果
设置pagingEnabled=YES即可，UIScrollView会被分割成多个独立页面，用户的滚动体验则变成了页面翻转
一般会配合UIPageControl增强分页效果，UIPageControl常用属性：
NSInteger numberOfPages : 总页数
NSInteger currentPage : 当前的页码
BOOL hidesForSinglePage : 当只有一页的时候，是否要隐藏视图
监听UIPageControl的页面改变：
// 添加监听器
[pageControl addTarget:self action:@selector(pageChange:) 
forControlEvents:UIControlEventValueChanged];
// 监听方法
- (void)pageChange:(UIPageControl *)pageControl 
1、使scrollview不要上下滑动，可以设置
scrollview.contentSize =  CGSizeMake(你要的长度, 0);

UINavigationController有一个toolBar属性
UIToolBar继承于UIView
UINavigationController底部工具栏默认处于隐藏的状态
每个视图控制器可以通过toolbarItems属性来定制toolBar

UINavigationController显示toolBar的方式
@property (nonatomic,getter=isToolbarHidden) BOOL toolbarHidden
//设置隐藏显示的属性

-(void)setToolbarHidden:(BOOL)hidden  animated:(BOOL)animated
//设置隐藏显示的方法

设置UIToolBar背景图片
-(void)setBackgroundImage:(UIImage *)backgroundImage forToolbarPosition:
(UIToolbarPosition)topOrBottom  barMetrics :(UIBarMetrics)barMetrics

UIButton *aBtn=[UIButton buttonWithType:UIButtonTypeCustom];
    [aBtn setFrame:CGRectMake(40, 100, 60, 60)];
    [aBtn setBackgroundImage:[UIImage imageNamed:@"111.png"] forState:UIControlStateNormal];
//button点击事件
    [aBtn addTarget:self action:@selector(btnShort:) forControlEvents:UIControlEventTouchUpInside];
    //button长按事件
    UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(btnLong:)]; 
    longPress.minimumPressDuration = 0.8; //定义按的时间
    [aBtn addGestureRecognizer:longPress];



-(void)btnLong:(UILongPressGestureRecognizer *)gestureRecognizer{
    if ([gestureRecognizer state] == UIGestureRecognizerStateBegan) {
        NSLog(@"长按事件");
        UIAlertView *alert=[[UIAlertView alloc] initWithTitle:@"消息" message:@"确定删除该模式吗？" delegate:self cancelButtonTitle:@"取消" otherButtonTitles:@"删除", nil];
        [alert show];
    }
}

//添加手势
    //UIGestuRecognizer
    //第一个参数表示点击手势发生后会调用这个对象的方法
    //第二个参数表示点击手势发生后会调用这个方法
    //tapAction:表示传一个参数,这个参数就是tapGersture对象
    UITapGestureRecognizer *tagGersture=[[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapAction:)];
    //将手势添加到视图上
    //[imageView addGestureRecognizer:tagGersture];
    
    //添加长按手势
    UILongPressGestureRecognizer *longPress=[[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(tapAction:)];
    //手势必须加到视图上才能起作用,这里传过去响应事件的参数是手势
    
    //@property (nonatomic) CFTimeInterval minimumPressDuration;
    longPress.minimumPressDuration=1;
    [imageView addGestureRecognizer:longPress];
    //开启用户的交互
    imageView.userInteractionEnabled=YES;//(默认是关闭用户交互的)

因为UITableView继承自UIScrollView,所以UIScrollView的代理方法h和属性,UITableView也可以使用,比如-(UIView*)ViewForZooming等等
NSIndexPath *path=[NSIndexPath indexPathForRow:row inSection:0];
NSMutableArray *deletePaths=[NSMutableArray array ];
for(NSArray *s in _deleteArray)
{
   int row=[_deleteArray indexOfObject:s];
   NSIndexPath *path=[NSIndexPath indexPathForRow:row inSection:0];
  [deletePaths addObject:path];
}
//[self.tableView reloadData];刷新表格,刷新表格的时候会重新初始化tabelView,
[self.tableView deleteRowsAtIndexPaths:deletePaths withRowAnimation:UITableViewRowAnimationLeft];

[cell.contentView addSubview:button];

UITableViewCell 继承自 UIView

UITableViewCell *cell=[UITableViewCell alloc]initWithStyle:<#(UITableViewCellStyle)#> reuseIdentifier:<#(NSString *)#>//这里reuseIdentifier:是为了给Cell做标记,以便于可以在缓存池中通过reuseIdentifier找到Cell去重复利用


UITableViewCellStyleSubtitle表示能够显示主标题和副标题,跟Cell.detailText对应


_dataArray[indexPath.row]数组可以用该方法取值,字典也可以_dataDictionary[indexPath.section][indexPath.row][@“key”]


//取消选择行的背景
    //[tableView deselectRowAtIndexPath:indexPath animated:YES];

//设置选择的样式
    cell.selectionStyle=UITableViewCellSelectionStyleGray;
    //提示符
    cell.accessoryType=UITableViewCellAccessoryCheckmark;

//设置分割线样式
    tableView.separatorStyle=UITableViewCellSeparatorStyleSingleLine;//none的时候就是没有分割线
]



tableView的二级.三级展开三级就是在二级视图的cell上监听事件插入和删除新的cell),要通过下面方法判断,显示
-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    
        if(_label.state==1)
        {
            return [_dataArray count];//当状态为展开时候
        }
        else
        {
            return 0;//当状态为未展开时候
        }
    
}


//这里设置额header的text的字体是固定的,要想改变必须用于上面的viewForHeaderInSection:方法来实现
-(NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section
{
    return [NSString stringWithFormat:@"第%C组",(unichar)(section+65)];
}


//刷新表格视图
        //[tableView reloadData];
  [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationRight];//删除(添加等等,跟NSMutableArray的方法名字类似)view上面的Row,也可以刷新视图,因为它删除是在屏幕View上删除


UITableViewCell *cell=[tableView cellForRowAtIndexPath:indexPath];




代理方法来操作UITableView的编辑

1)设置编辑模式
一.设置能否进入编辑模式
设置setEditing:Animation:可以编辑(或者滑动cell,系统默认情况下为删除,而且滑动Cell也只能在下面设置编辑模式为delete的情况下才能实现)

二设置进入编辑模式后的编辑模式状态,即设置编辑模式图标
-(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath
//这个是调用编辑模式时候—如滑动cell(或者设置setEditing:Animation:可以编辑)—-的模式,可以返回编辑,插入等等模式,但是事实上可以大致看成只是模式图片上的不同.真正的删除,插入等等操作还需要自己去手动输入代码

三.设置进入编辑模式后,点击编辑图标时的操作(提交编辑模式)
-(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath
//调用:再进入编辑模式后,按相应的模式下对应的操作,进行的调用函数

2)删除
需要在上面第三步:
-(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath
来设置,当编辑模式设置为delete的时候,点击编辑模式删除图标,来进行删除,
3)插入
其实跟删除原理是一样子的,也是在上面第二步进行的操作
-(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath
来设置,当编辑模式设置为insert的时候,点击编辑模式+图标,来进行插入,

4)移动(但是这个要只有在上面设置编辑模式setEditing:Animation:为能编辑(不能通过滑动Cell来进入)后才能进行以下的操作)
一.设置能否移动
-(BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath

二.设置将要交换到的目的位置
(NSIndexPath *)tableView:(UITableView *)tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath
////返回交换的位置,sourceIndexPath需要交换的位置/proposedDestinationIndexPath将要交换到的位置


三.在第二步传过来的NSIndexPath目的位置,来调用该方法
-(void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath——这一步必须实现,否则进入编辑模式的时候没有那个移动的图标


UITableView上的各种编辑模式图标显示,实现方法
delete删除,要实现以下两个方法
-(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath
-(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath
insert插入,要实现以下两个方法
-(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath
-(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath
move移动,要实现以下一个方法
-(void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath



- (NSArray *)visibleCells;
(NSArray *)indexPathsForVisibleRows;可见的Cell

-(NSString*)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath设置删除模式的文字



//设置是否选中
-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    [tableView deselectRowAtIndexPath:indexPath animated:YES];
}
//设置选中Cell的背景视图
UIView *view=[[UIView alloc]init];
    view.backgroundColor=[UIColor redColor];
    view.alpha=0.5;
    cell.selectedBackgroundView=view;

//这个是自定义Cell上面的方法
-(void)setSelected:(BOOL)selected animated:(BOOL)animated
{
 [super setSelected:selected animated:animated];
    //这里继承父类方法,在点击Cell以前,系统先自动调用下面的语句(每次设置一个Cell就调用一次setSelected:selected animated:方法)
#if 0
    UILabel *myLabel=[[UILabel alloc]initWithFrame:CGRectMake(100, 0, 100, 30)];
    myLabel.text=self.label;
    myLabel.textColor=[UIColor blackColor];
    UILabel *myDetail=[[UILabel alloc]initWithFrame:CGRectMake(110, 30, 100, 14)];
    myDetail.text=self.detailLable;
    myDetail.textColor=[UIColor redColor];
    [self addSubview:myLabel];
    [self addSubview:myDetail];
    //self.backgroundColor=[UIColor redColor];
#endif
}

cell的bounds.size的默认height和weightCustomTableViewCellDemo[26106:1569991] 44.000000,320.000000
自定义Cell的时候要注意:最好自己去设置控件的frame ,而不要这样做:
self.bounds.size.height,self.bounds.size.width

设置headerView的方式有两种
一:
tableView.tableHeaderView=cell;
header的bounds跟它headerView的cell的frame有关
二:
-(UIView*)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section
{
    MyTableViewCell* cell=[[MyTableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@"cell"];
    [cell config:_dataArray];
    return cell;(设置视图的时候,返回的视图可以不设置frame,因为不管frame如何系统都会重新设置它的frame为整个hearView的大小,所以一般情况下要想设置将要加进去自定义的view,要加在返回的视图上面,这样你设置的frame 才有效)
}
-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section
{
    return 160;
}
-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    return 1;
}

tableView处于编辑模式下,无法点击选择Cell
第一种:
//    UINib *nib=[UINib nibWithNibName:@"DataCell" bundle:nil];
//    [self.tableView registerNib:nib forCellReuseIdentifier:@“cellId"];
这中是注册cell,要写在tableView的初始化后面,否则系统会找不到Cell地址
DataCell *cell=[tableView dequeueReusableCellWithIdentifier:@"cellId"];
//    DataModel *model=_dataArray[indexPath.row];
//    [cell config:model];
//    return cell;
第二种:
cell=[[[NSBundle mainBundle]loadNibNamed:@"DataCell" owner:self options:nil]lastObject];从xib中获取cell,这个方法不用去注册cell,注意这个要将Restoration ID设置为你重用Cell的identifier
static NSString *ID=@"cellID";
    DataCell *cell=[tableView dequeueReusableCellWithIdentifier:ID];
    if(cell==nil)
    {
        cell=[[[NSBundle mainBundle]loadNibNamed:@"DataCell" owner:self options:nil]lastObject];
    }
  return cell;


//创建索引
//section分组Index索引Titles标题
-(NSArray*)sectionIndexTitlesForTableView:(UITableView *)tableView
{
    NSMutableArray *indexArray=[NSMutableArray array];
    [indexArray addObject:@"@"];
    for(int i='A';i<='Z';i++)
    {
        [indexArray addObject:[NSString stringWithFormat:@"%c",i]];
    }
    return indexArray;
}
////响应点击索引时的委托方法
-(NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index
{
    //return -1没有什么作用,tableView不做任何操作
    if(index==0)
    {

        tableView.contentOffset=CGPointMake(0, 0);
        //[tableView reloadData];
    }
    return  index-1;
}

当我们选中一个tableViewCell时，首先调用didDeselectRowAtIndexPath方法，将之前选中的tableViewCell取消选中，然后再调用didSelectRowAtIndexPath方法，将选中的tableViewCell选中，所以我们要tableView支持多选时，要将didDeselectRowAtIndexPath方法注释掉。
-(void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath



tableView deselectRowAtIndexPath:<#(NSIndexPath *)#> animated:<#(BOOL)#>取消选中行(去掉选中行的蓝色背景)

@property (nonatomic) UITableViewCellAccessoryType    accessoryType;              // default is UITableViewCellAccessoryNone. use to set standard type
@property (nonatomic, retain) UIView                 *accessoryView;

-(UITableViewCell*)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *ID = @"cellID";
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];
    if(cell==nil)
    {
        cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID];
    }
    DataModel *model = _dataArray [indexPath.row];
    NSLog(@"%@",model.imgurl);
    UIImageView *imageView = [[UIImageView alloc]init];
    imageView.frame = CGRectMake(5, 5, 90, 90);//cell.imageView.frame;这里不能拿系统自带的cell.imageView.frame来设置,用了之后是设置不了frame的.
    [imageView sd_setImageWithURL:[NSURL URLWithString:model.imgurl]];
    [cell addSubview:imageView];//这个样子用自定义的UIImageVIew来占位,否则要滚动UIScrollView,才能刷新图片
    NSLog(@"%p",cell);
    return cell;
}

self.backgroundView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@"appdetail_background.png"]];

1、先创建一个NSURL 
2、在通过NSURL创建NSURLRequest，可以指定缓存规则和超时时间 
3、创建NSURLConnection实例，指定NSURLRequest和一个delegate对象 
   如果创建失败，则会返回nil,如果创建成功则创建一个NSMutalbeData的实例用来存储数据 
代码： 
    NSURL *url = [NSURL URLWithString:@"http://192.168.2.128:9090/ssonew/login/UserLogin.action?name=mql&psd=123456"];
    NSURLRequest *request = [[NSURLRequest alloc]initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30];
    self.theConncetion = [[NSURLConnection alloc]initWithRequest:request delegate:self startImmediately:YES];
    
    if (_theConncetion) {
        self.receiveData = [[NSMutableData alloc]init];
    }
NSURLConnection有3个初始化函数，只有第一个初始化函数可以做到创建连接但是并 不马上开始下载，而是通过start：开始，调用该初始化函数时，startImmediately传NO

- (id)initWithRequest:(NSURLRequest *)request delegate:(id)delegate startImmediately:(BOOL)startImmediately
- (id)initWithRequest:(NSURLRequest *)request delegate:(id)delegate;
+ (NSURLConnection*)connectionWithRequest:(NSURLRequest *)request delegate:(id)delegate;

当收到initWithRequest: delegate：或收到connectionWithRequest: delegate: 消息时，下载会立即开始，在代理（delegate） 
收到connectionDidFinishLoading：或者connection：didFailWithError：消息之前 
可以通过给连接发送一个cancel：消息来中断下载


NSURLConnectionDataDelegate:
(NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response;
//:这个方法在请求将要被发送出去之前会调用.
//返回值是一个NSURLRequest,就是那个真正将要被发送的请求
//第二个参数request就是被重定向处理过后的请求
//第三个参数response是触发重定向请求的响应包.默认是支持跳转的。
- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;
//(通过链接)接收响应,//注意这里将NSURLResponse对象转换成NSHTTPURLResponse对象才能使用
(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data;
//(通过链接)接收数据
////在这个方法实现中，可以加入一个进度指示器，提示用户下载进度 
- (void)connectionDidFinishLoading:(NSURLConnection *)connection;
//(链接)结束加载
 当下载的过程中有错误发生的时候，代理会收到一个connection：didFailWithError消息
 消息参数里面的NSError对象提供了具体的错误细节，它也能提供在用户信息字典里面失败的
 url请求（使用NSErrorFailingURLStringKey）
 
 当代理接收到连接的connection：didFailWithError消息后，对于该连接不会再收到任何消息

三种网络解析(其实说白了,JSON解析是对获取到的网络二进制数据进行解析成数组或者字典)
:
第一种:(NSString)
NSURL——->>NSString 
[NSString stringWithContentsOfURL:url encoding :NSUTF8StringEncoding error:nil]

第二种:
NSURLConnection
NSURL————->NSRequest———>NSURLConnection:(代理方法);
数据: 网络是在代理方法里面返回的                                  
代理方法:(思路:向网络端口发送请求,收到网络接口发回来的答复,在接收传过来的数据,最后接受加载)
-(NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response
-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response
-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data
//在这个代理方法里返回二进制网络数据(为了jave和iOS通用,一般都用二进制)
-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error
-(void)connectionDidFinishLoading:(NSURLConnection *)connection
//向利用上面代理方法获得的二进制数据,需要用JSON解析对二进制数据解析,JSON解析的数据为字典或者数组

第三种:
ASI(第三方库)—-手动发送同异步开始(不能用在NSobject类里面)
NSURL———>ASIHTTPRequest— [request startAsynchronous]—>代理方法获取数据
//发送请求,异步请求
#import”ASIHTTPRequest.h"
-(void)requestFinished:(ASIHTTPRequest *)request

第四种
AFNetWorking(第三方库)
#import “AFHTTPRequestOperationManager.h"
1)先创建对象
2)设置返回的类型
manger.responseSerializer=[AFHTTPResponseSerializer serializer]
3)发送GET请求,并返回二进制数据
GET:  parameters: success:^(AFHTTPRequestOperation *operation, id responseObject) {这里成功的时候返回二进制数据}:failure:

第二种NSURLConnection的POST请求
NSURL—->NSURLRequest(设置请求方式setHTTPMethod:,设置请求体setHTTPBody(NSString—>NSData),设置值:数据的大小,数据类型,设置代理)——>
//创建一个NSMutableURLRequest
NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
//设置post请求方式
[request setHTTPMethod:@"post"];
//设置请求体
[request setHTTPBody:bodyData];
//设置其它值
//1(设置请求数据的大小)
[request setValue:[NSString stringWithFormat:@"%ld",bodyData.length] forHTTPHeaderField:@“content-length"];
//2(设置请求数据的类型
[request setValue:@"application/x-www-from-urlencoded" forHTTPHeaderField:@"content-Type"];

第三种ASIFormDataRequest的POST请求
NSURL———->ASIFormDataRequest(设置请求类型setRequestMethod:,设置请求体:以键值对的形式添加(NSString),设置代理)——->发送请求[request startAsynchronous];

总结:post请求要设置请求方式,请求体(第二种是加NSData,第三种是字典的形式),(有时候还需要设置请求值,数据大小,请求类型),其实post和get传递请求的请求体都是键值对的形式,只是get的请求是在URL上,而post的请求是以请求体的形式存在,独立于URL的(这样确保安全性),NSMutableRequest(setValue),NSFormDataRequest(addValue),parameters:(NSDictionary),它们三个都需要在请求requeset里去加请求体

当请求方法是POST的时候，查询字符串将从HTTP请求体中传递而不是通过URL。请求体是WSGI服务器提供的类似于环境变量的wsgi.input文件。
有必要知道应答体的大小，以便从wsgi.input中读出它。WSGI明细规定，CONTENT_LENGTH变量来存储大小，它可以为空或者被忽略，所以读它的时候把它放到一个try/except块中。

获取网络图片:
#import “UIImageView+WebCache.h"
leftImageView sd_setImageWithURL:url//这个是设置需要设置图片的imageView

1)请求方式不同
GET
请求提交的数据会附在URL之后，以?分割URL和传输数据，参数之间以&相连。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中
文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。根据HTTP协议，即GET请求将提交的数据放在HTTP协议头中）
 
POST
把提交的数据则放置在是HTTP包的包体中（即，POST请求将提交的数据放在HTTP请求的实体数据中）
 
实例如下：
 
GET实例：
 GET/books/?name=Professional%20Ajax   vHTTP/1.1 
Host: www.wrox.com 
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) 
Gecko/20050225 Firefox/1.0.1 
Connection: Keep-Alive
 
POST
实例：
POST / HTTP/1.1 
Host: www.wrox.com 
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) 
Gecko/20050225 Firefox/1.0.1 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 40 
Connection: Keep-Alive 
(此处空一行）
name=Professional%20Ajax&publisher=Wiley
 
2)请求提交的数据量的限制
GET请求：由于提交的数据都附加在URL中，而URL不存在参数上限的问题，
且HTTP协议规范没有对URL长度进行限制，所以，理论上，
GET请求提交的数据大小没有上限。但是同时，因为提交的数据都附加在
URL中，提交的数据量，又与浏览器允许的URL的长度有关理论上讲，

POST
是没有大小限制的。HTTP协议规范也没有进行大小限制，所以，
POST数据是没有限制的。事实上，起限制作用的是服务器的处理程序
的处理能力。对于IIS 6.0，微软出于安全考虑，加大了限制：
a)IIS 6.0默认
ASP POST数据量最大为200KB，每个表单域限制是100KB。
b)IIS 6.0默认
上传文件的最大大小是4MB。
 c)IIS 6.0默认
最大请求头是16KB。
d)IIS 6.0
之前没有这些限制
 
3)安全性
POST的安全性要比GET的安全性高。这里所说的安全性的含义是真正的
Security的含义，
通过GET提交数据，用户名和密码将明文出现在URL上，这就导致在“登录
页面被浏览器缓存”，或者“其他人查看浏览器的历史纪录”时，别人就可以
拿到你的账号和密码了
除此之外，使用
GET提交数据还可能会造成Cross-site request forgery攻击。（
Cross Site Request Forgery (跨站伪造请求)，经常会利用路由信息协
议的漏洞，以及DNS下毒的方式，让使用者在连往目的网页前，先被带到黑
客服务器，并在此下手窃取资料。
)但是在分页程序中，用GET方式就比用POST好
 
4)提交表单的方式
在ASP中，服务端获取GET请求参数用Request.QueryString（在JSP中，用
request.GETParameter(\"XXXX\")来获取），获取POST请求参数用Request.Form
。，在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而
$_REQUEST则可以获取GET和POST两种请求中的数据。值得注意的是，JSP
中使用request和PHP中使用$_REQUEST都会有隐患。
 总结一下，
GET
是向服务器发索取数据的一种请求，而
POST
是向服务器提交数据的一种请求，在FORM(表单）中，Method
默认为"GET"，实质上，GET和POST只是发送机制不同，并不是一个取一个发。

int state=_pageCtrol.currentPage%2;
    if(!state)//注意:有时候这里直接if(!_pageCtrol.currentPage%2)判断的话系统会判断不了,所以,最好用一个值先接受_pageCtrol.currentPage%2,再判断
  UIPageController的frame的height不管你设置多少,都是无效的,width不能决定点点的宽度 

-(void)setImageWithURL:(NSURL *)url
{
dispatch_queue_t   queue=dispatch_queue_creat(“c语言的队列的名字”,NULL(保留的dispatch_queue属性,将其设置为NULL即可));
//这里创建的queue仅仅只是局部变量,
dispatch_async(queue,^{子线程执行的代码块.})
//dispatch_async是指定与主线程之间的关系是异步还是同步
dispatch_sync(dispatch_get_main_queue(), ^{这里是返回主线程的同时执行的语句});
}
/* dispatch_async(queue, task1);
    dispatch_async(queue, task2);
    如果是这样子的话
    利用了 dispatch_queue 的 FIFO 特性，确保 task1 先于 task2 执行，而 task2 必须等待直到 task1 执行完毕才开始干正事，
    先进来的限执行先执行
   */
/*
 总体来说:
1)先创建将要加到线程的队列
2)在说明该线程是与主线程同步还是异步线程
3)系统来回拿反复调用主线程和该线程的语句(也就是说同一个时间点只能执行在一个线程--但是这个只是在单核CPU才是这样子的)
4)dispatch_sync(dispatch_get_main_queue(), ^{这里是返回主线程的同时执行的语句});
 这里是线程结束时候返回到主线程去,//这里该线程就把该队列在线程中释放掉了

 */

4. dispatch_queue分为两种：
　　a. Serial Dispatch Queue: 线性执行的线程队列，遵循FIFO(First In First Out)原则;
dispatch_queue_t serialQueue = dispatch_queue_create("com.mark.serialQueue", NULL);
　　b. Concurrent Dispatch Queue: 并发执行的线程队列，并发执行的处理数取决于当前状态。
// 并发执行线程队列
dispatch_queue_t concurrentQueue = dispatch_queue_create("com.mark.concurrentQueue", DISPATCH_QUEUE_CONCURRENT);

5. 系统的Dispatch Queue:
　　a. Main Dispatch Queue: 主线程队列(Serial Queue), 在程序的RunLoop中执行。
　　b. Global Dispatch Queue: 系统中所有应用程序共用的全局队列(Concurrent Queue), 一般不必创建新的Dispatch Queue，使用此Queue就可以了。
Global Diapacth Queue有4个优先级：High Priority(高)、Default Priority(默认)、Low Priority(低)、Background Priority(后台)。


11. 线程队列的挂起与执行：
// 挂起队列
dispatch_suspend(queue);
// 恢复队列执行
dispatch_resume(queue);

主队列
dispatch_queue_t mainQueue = dispatch_get_main_queue();

获取当前队列
dispatch_queue_t currentQueue = dispatch_get_current_queue();

NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)

个人理解为，在基地址下NSUserDomainMask，获取在在当前程序中 NSDocumentDirectory 文件目录

//时间
    NSString *dateString = model.expireDatetime;
    dateString = [dateString substringToIndex:dateString.length - 2];
    NSDateFormatter *df = [[NSDateFormatter alloc]init];
    [df setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    NSDate *expireFormat = [df dateFromString:dateString];
//创建一个NSCalendar对象
    NSCalendar *calendar = [NSCalendar currentCalendar];
//取到两个日期之间的差值
    //第一个参数:年月日时分秒
    unsigned int unit = NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay | NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond;//设置你要的时间格式
    NSDateComponents *dc = [calendar components:unit fromDate:[NSDate date] toDate:expireFormat options:0];//取两个时间的差值,并以设置的日历时间格式显示//Components组件
    self.timeLabel.text = [NSString stringWithFormat:@“剩余:%2ld:%2ld:%2ld",dc.hour,dc.minute,dc.second];


NSString *lastPrice = [NSString stringWithFormat:@"$:%@",model.lastPrice];
    
    NSAttributedString *priceString = [[NSAttributedString alloc]initWithString:lastPrice attributes:@{NSStrikethroughStyleAttributeName:@1}];
    //在文字上加横线
self.lastPriceLabel.attributedText = string;




//"Tue Jan 20 17:25:35 +0800 2015"
   // 1.将新浪时间字符串转为NSDate对象
    NSDateFormatter *fmt = [[NSDateFormatter alloc]init];
    [fmt setDateFormat:@"EEE MMM dd HH:mm:ss zzzz yyyy"];
    fmt.locale = [[NSLocale alloc]initWithLocaleIdentifier:@“en_US”];//locale语言环境,就仅仅比正常时间计算的多这个语句
    NSDate *date = [fmt dateFromString:statusModel.created_at];
    NSTimeInterval delta = [[NSDate date] timeIntervalSinceDate:date];
    // 4.根据时间间隔算出合理的字符串
    if (delta < 60) { // 1分钟内
        _datelabel.text = @"刚刚";
    } else if (delta < 60 * 60) { // 1小时内
        _datelabel.text = [NSString stringWithFormat:@"%.f分钟前", delta/60];
    } else if (delta < 60 * 60 * 24) { // 1天内
        _datelabel.text = [NSString stringWithFormat:@"%.f小时前", delta/60/60];
    } else {
        fmt.dateFormat = @"MM-dd HH:mm";
        _datelabel.text = [fmt stringFromDate:date];
    }

+ (instancetype)sharedManager
{
    static DownloadManager *manager = nil;
    //GCD注意这里要用static
    static dispatch_once_t once;
    
    dispatch_once(&once, ^{
        if(nil == manager)
        {
            manager = [[DownloadManager alloc]init];
        }
    });
    return manager;
}

这样式手动添加线程,因此在dealloc里面一定要移除,dealloc是视图消失的时候调用的
消息控制中心也是


当navigationController推出视图时才调用viewDidload方法,init不会调用viewDidload方法,可以理解成视图要显示 才调用viewDidload
另外先调用viewDidload,之后才调用willAppear方法

UISearchControllerDelegate,UISearchResultsUpdating,UISearchBarDelegate
    //创建一个搜索视图控制器
    _searchCtrl = [[UISearchController alloc] initWithSearchResultsController:nil];
    //设置代理
    _searchCtrl.delegate = self;
    //设置搜索结果的代理
    _searchCtrl.searchResultsUpdater = self;
    //搜索视图控制器默认有一个搜索框视图
    //搜索框视图是一个UISearchBar类型的对象
    //可以通过_searchCtrl.searchBar来获取和使用它
    //_searchCtrl.searchBar;
    
    //去掉前面的遮罩
    _searchCtrl.dimsBackgroundDuringPresentation = NO;
    //设置搜索框的大小
    [_searchCtrl.searchBar sizeToFit];
    
    //将搜索框作为表格视图的表格头
    //表格头:_tbView.tableHeaderView
    //表格尾:_tbView.tableFooterView
    _tbView.tableHeaderView = _searchCtrl.searchBar;
-(void)willPresentSearchController:(UISearchController *)searchController
//搜索时候更新搜索结果数据源
- (void)updateSearchResultsForSearchController:(UISearchController *)searchController
//结束搜索状态的时候调用
- (void)didDismissSearchController:(UISearchController *)searchController 

//自己实现搜索功能
    UISearchBar *searchBar = [[UISearchBar alloc] initWithFrame:CGRectMake(0, 64, 375, 40)];
    searchBar.delegate = self;
    [self.view addSubview:searchBar];
 //自己实现搜索功能
-(void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText;

-(void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar;

-(void)searchBarTextDidEndEditing:(UISearchBar *)searchBar;

- (void)setValues:(NSDictionary *)values
{
    Class c = [self class];//取得当前类类型
    
    while (c) {
        // 1.获得所有的成员变量
        unsigned int outCount = 0;//开辟一块无符号类型的内存地址
        Ivar *ivars = class_copyIvarList(c, &outCount);//获取类成员变量列表,outCount为类成员数量class_copyIvarList(c, &outCount)这句的意思就是把c类中成员数量的个数放在outCount的里,通过&outCount找到地址
        //变量成员变量列表,其中每个变量都是Ivar类型的结构体
        for (int i = 0; i<outCount; i++) {
            Ivar ivar = ivars[i];//Ivar这方法能让你得到对象属性名字，内存地址和Objective-C type encoding类型。
            // 2.属性名
            //获取属性名
            //若此变量未在类结构体中申明而只申明为property,则变量名加前缀'_'下划线
            //比如@property(retain)NSString *abc;则key == _abc;
            NSMutableString *name = [NSMutableString stringWithUTF8String:ivar_getName(ivar)];
           // 删除最前面的_
            [name replaceCharactersInRange:NSMakeRange(0, 1) withString:@""];
            
            // 3.取出属性值
            NSString *key = name;
            if ([key isEqualToString:@"desc"]) {
                key = @"description";
            }
            if ([key isEqualToString:@"ID"]) {
                key = @"id";
            }
            id value = values[key];//　获取变量值
            if (!value) continue;//continue跳出当前一次循环,进入下一次循环
            // 4.SEL
            // 首字母
            NSString *cap = [name substringToIndex:1];
            // 变大写
            cap = cap.uppercaseString;
            // 将大写字母调换掉原首字母
            [name replaceCharactersInRange:NSMakeRange(0, 1) withString:cap];
            // 拼接set
            [name insertString:@"set" atIndex:0];
            // 拼接冒号:
            [name appendString:@":"];
            SEL selector = NSSelectorFromString(name);
            
            // 5.属性类型
            NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];
            
            if ([type hasPrefix:@"@"]) { // 对象类型
                objc_msgSend(self, selector, value);
            } else  { // 非对象类型
                if ([type isEqualToString:@"d"]) {
                    objc_msgSend(self, selector, [value doubleValue]);
                } else if ([type isEqualToString:@"f"]) {
                    objc_msgSend(self, selector, [value floatValue]);
                } else if ([type isEqualToString:@"i"]) { 
                    objc_msgSend(self, selector, [value intValue]);
                }  else { 
                    objc_msgSend(self, selector, [value longLongValue]);
                }
            }
        }
        
        c = class_getSuperclass(c);
    }
}
